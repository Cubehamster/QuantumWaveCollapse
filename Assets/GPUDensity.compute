// GPUDensity.compute
// Separable Gaussian (or copy) over an integer scatter buffer.

#pragma kernel ClearCounts
#pragma kernel ScatterPoints
#pragma kernel BlurH
#pragma kernel BlurV
#pragma kernel CopyCountsToFloat
#pragma kernel TestPattern

// ===== Resources =====
RWTexture2D<uint> _Counts; // integer UAV (RInt)
Texture2D<uint> _CountsIn; // SRV for blur/copy reads
Texture2D<float> _InFloat; // SRV for vertical blur
RWTexture2D<float> _Out; // float UAV output
StructuredBuffer<float2> _Positions;

// ===== Params =====
int2 _TexSize;
int _Num;
float2 _MinB;
float2 _InvSize;
int _Radius;
float _Sigma;

// ===== Utils =====
float GaussianWeight(int k, float sigma)
{
    float kk = (float) (k * k);
    float denom = 2.0 * max(1e-8, sigma * sigma);
    return exp(-kk / denom);
}

// ===== Kernels =====
[numthreads(8, 8, 1)]
void ClearCounts(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TexSize.x || id.y >= _TexSize.y)
        return;
    _Counts[int2(id.xy)] = 0u;
}

[numthreads(256, 1, 1)]
void ScatterPoints(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _Num)
        return;

    float2 p = _Positions[i];
    float2 uv = saturate((p - _MinB) * _InvSize);
    int2 pix = int2(uv * (float2) (_TexSize - 1));

    // atomic increment into integer buffer
    InterlockedAdd(_Counts[pix], 1u);
}

[numthreads(8, 8, 1)]
void BlurH(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TexSize.x || id.y >= _TexSize.y)
        return;

    int2 p = int2(id.xy);
    int r = _Radius;

    if (r <= 0)
    {
        _Out[p] = (float) _CountsIn.Load(int3(p, 0)).r;
        return;
    }

    float sigma = (_Sigma > 0.0) ? _Sigma : max(0.5, (float) r * 0.5);

    int w = _TexSize.x;
    float acc = 0.0;
    float wsum = 0.0;

    [loop]
    for (int k = -r; k <= r; k++)
    {
        int x = clamp(p.x + k, 0, w - 1);
        float wgt = GaussianWeight(k, sigma);
        float val = (float) _CountsIn.Load(int3(x, p.y, 0)).r;
        acc += val * wgt;
        wsum += wgt;
    }

    _Out[p] = acc / max(1e-8, wsum);
}

[numthreads(8, 8, 1)]
void BlurV(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TexSize.x || id.y >= _TexSize.y)
        return;

    int2 p = int2(id.xy);
    int r = _Radius;

    if (r <= 0)
    {
        _Out[p] = _InFloat.Load(int3(p, 0)).r;
        return;
    }

    float sigma = (_Sigma > 0.0) ? _Sigma : max(0.5, (float) r * 0.5);

    int h = _TexSize.y;
    float acc = 0.0;
    float wsum = 0.0;

    [loop]
    for (int k = -r; k <= r; k++)
    {
        int y = clamp(p.y + k, 0, h - 1);
        float wgt = GaussianWeight(k, sigma);
        float val = _InFloat.Load(int3(p.x, y, 0)).r;
        acc += val * wgt;
        wsum += wgt;
    }

    _Out[p] = acc / max(1e-8, wsum);
}

[numthreads(8, 8, 1)]
void CopyCountsToFloat(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TexSize.x || id.y >= _TexSize.y)
        return;
    int2 p = int2(id.xy);
    _Out[p] = (float) _CountsIn.Load(int3(p, 0)).r;
}

// Optional visual to confirm pipeline
[numthreads(8, 8, 1)]
void TestPattern(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TexSize.x || id.y >= _TexSize.y)
        return;
    float2 uv = (float2) id.xy / (float2) _TexSize;
    _Out[int2(id.xy)] = 10.0 * exp(-30.0 * dot(uv - 0.5, uv - 0.5));
}
